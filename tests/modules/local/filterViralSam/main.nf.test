import java.util.zip.GZIPInputStream
nextflow_process {
    name "Test process FILTER_VIRAL_SAM"
    script "modules/local/filterViralSam/main.nf"
    process "FILTER_VIRAL_SAM"
    tag "module"
    tag "filterViralSam"

    test("Should keep all reads when all are in filter list") {
        tag "expect_success"
        tag "keep_all_reads"
        config "tests/configs/run.config"
        setup {
            run("GZIP_FILE_BARE", alias: "GZIP_FILE_BARE_ALL_READS_FASTQ") {
                script "modules/local/gzipFile/main.nf"
                process {
                    '''
                    input[0] = Channel.of(tuple(file("${projectDir}/test-data/toy-data/filter-viral-sam/keep-all-reads.fastq")))
                    '''
                }
            }
            run("GZIP_FILE_BARE", alias: "GZIP_FILE_ALL_READS_SAM") {
                script "modules/local/gzipFile/main.nf"
                process {
                    '''
                    input[0] = Channel.of(tuple(file("${projectDir}/test-data/toy-data/filter-viral-sam/filter-viral-sam-test.sam")))
                    '''
                }
            }
        }
        when {
            params {
            }
            process {
                '''
                input[0] = Channel.of("test_sample")
                    | combine(GZIP_FILE_ALL_READS_SAM.out)
                    | combine(GZIP_FILE_BARE_ALL_READS_FASTQ.out)
                input[1] = 5.0
                '''
            }
        }
        then {
            // Should run without failures
            assert process.success
            
            def outputFile = path(process.out.sam[0][1])
            def outputLines = outputFile.linesGzip
            def nonHeaderLines = outputLines.findAll { !it.startsWith('@') }
            
            // Should keep all 6 reads since all are in the filter list
            assert nonHeaderLines.size() == 6
            
            // Verify all read names are present
            def readNames = nonHeaderLines.collect { it.split('\t')[0] }.unique()
            assert 'read1' in readNames
            assert 'read2' in readNames  
            assert 'read3' in readNames
        }
    }

    test("Should filter out all reads when only contaminants in filter list") {
        tag "expect_success"
        tag "contaminants_only"
        config "tests/configs/run.config"
        setup {
            run("GZIP_FILE_BARE", alias: "GZIP_FILE_BARE_CONTAM_ONLY_FASTQ") {
                script "modules/local/gzipFile/main.nf"
                process {
                    '''
                    input[0] = Channel.of(tuple(file("${projectDir}/test-data/toy-data/filter-viral-sam/keep-up-reads.fastq")))
                    '''
                }
            }
            run("GZIP_FILE_BARE", alias: "GZIP_FILE_CONTAM_ONLY_SAM") {
                script "modules/local/gzipFile/main.nf"
                process {
                    '''
                    input[0] = Channel.of(tuple(file("${projectDir}/test-data/toy-data/filter-viral-sam/filter-viral-sam-test.sam")))
                    '''
                }
            }
        }
        when {
            params {
            }
            process {
                '''
                input[0] = Channel.of("test_sample")
                    | combine(GZIP_FILE_CONTAM_ONLY_SAM.out)
                    | combine(GZIP_FILE_BARE_CONTAM_ONLY_FASTQ.out)
                input[1] = 10.0
                '''
            }
        }
        then {
            // Should run without failures
            assert process.success
            
            def outputFile = path(process.out.sam[0][1])
            def outputLines = outputFile.linesGzip
            def nonHeaderLines = outputLines.findAll { !it.startsWith('@') }
            
            // Should remove all
            assert nonHeaderLines.size() == 0
        }
    }
}
