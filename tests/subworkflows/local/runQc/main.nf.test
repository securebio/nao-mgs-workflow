// Helper function: Validate TSV structure by reading lines directly and splitting by tabs.
def validateTsvStructure = { tsv_file, expected_col_count, expected_stage, expected_sample ->
    def lines = path(tsv_file).linesGzip
    assert lines.size() >= 1 : "TSV file must have at least a header row"
    def header = lines[0].split("\t")
    assert header.size() == expected_col_count : "Expected ${expected_col_count} columns, got ${header.size()}"
    if (lines.size() > 1) {
        def first_data_row = lines[1].split("\t", -1)
        def stage_idx = header.findIndexOf { it == "stage" }
        def sample_idx = header.findIndexOf { it == "sample" }
        assert stage_idx >= 0 : "Header must contain 'stage' column"
        assert sample_idx >= 0 : "Header must contain 'sample' column"
        assert first_data_row[stage_idx] == expected_stage : "Expected stage '${expected_stage}', got '${first_data_row[stage_idx]}'"
        assert first_data_row[sample_idx] == expected_sample : "Expected sample '${expected_sample}', got '${first_data_row[sample_idx]}'"
    }
}

// Helper function: Validate a QC tuple (sample, basic, adapt, qbase, qseqs, lengths)
def validateQcTuple = { qc_tuple, expected_stage ->
    def tsv_basic = path(qc_tuple[1]).csv(sep: "\t", decompress: true)
    assert tsv_basic.rowCount == 1
    assert tsv_basic.columnCount == 18
    assert tsv_basic.columns["stage"][0] == expected_stage
    def stage = tsv_basic.columns["stage"][0]
    def sample = tsv_basic.columns["sample"][0]
    validateTsvStructure(qc_tuple[2], 6, stage, sample)
    validateTsvStructure(qc_tuple[3], 5, stage, sample)
    validateTsvStructure(qc_tuple[4], 5, stage, sample)
    validateTsvStructure(qc_tuple[5], 5, stage, sample)
}

nextflow_workflow {

    name "Test subworkflow RUN_QC"
    script "subworkflows/local/runQc/main.nf"
    workflow "RUN_QC"
    tag "subworkflow"
    tag "run_qc"

    test("Should run without failures on paired (interleaved) data") {
        config "tests/configs/run.config"
        tag "expect_success"
        tag "interleaved"
        when {
            params {}
            workflow {
                """
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/tiny-index/reads/interleaved.fastq"))
                input[1] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/tiny-index/reads/interleaved.fastq"))
                input[2] = Channel.of(false)
                """
            }
        }
        then {
            assert workflow.success
            validateQcTuple(workflow.out.pre_qc[0], "raw")
            validateQcTuple(workflow.out.post_qc[0], "cleaned")
        }
    }

    test("Should run without failures on single-end data") {
        config "tests/configs/run.config"
        tag "expect_success"
        tag "single_end"
        when {
            params {}
            workflow {
                """
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/tiny-index/reads/R1.fastq"))
                input[1] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/tiny-index/reads/R1.fastq"))
                input[2] = Channel.of(true)
                """
            }
        }
        then {
            assert workflow.success
            validateQcTuple(workflow.out.pre_qc[0], "raw")
            validateQcTuple(workflow.out.post_qc[0], "cleaned")
        }
    }

    test("Should handle empty input files properly") {
        config "tests/configs/run.config"
        tag "expect_success"
        tag "empty_input"
        when {
            params {}
            workflow {
                """
                input[0] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/empty_file.txt"))
                input[1] = Channel.of("test")
                    | combine(Channel.of("${projectDir}/test-data/toy-data/empty_file.txt"))
                input[2] = Channel.of(true)
                """
            }
        }
        then {
            assert workflow.success
            validateQcTuple(workflow.out.pre_qc[0], "raw")
            validateQcTuple(workflow.out.post_qc[0], "cleaned")
        }
    }
}
