nextflow_workflow {

    name "Test subworkflow MERGE_JOIN_READS_LIST"
    script "subworkflows/local/mergeJoinReadsList/main.nf"
    workflow "MERGE_JOIN_READS_LIST"
    tag "subworkflow"
    tag "merge_join_reads"

    test("Should run without failures on interleaved Illumina input") {
        tag "expect_success"
        tag "interleaved"
        config "tests/configs/run.config"
        when {
            params {
            }
            workflow {
                '''
                input[0] = Channel.of(["test", ["${projectDir}/test-data/mergeJoinReadsList/test_000_interleaved.fastq"]])
                input[1] = Channel.of(false)
                '''
            }
        }
        then {
            // Should run without failures
            assert workflow.success
            // Merged read count should equal input pairs
            def fastq_in = path(workflow.out.input_reads[0][1][0]).fastq
            def fastq_out = path(workflow.out.single_reads[0][1][0]).fastq
            assert fastq_in.sequences.size() == fastq_out.sequences.size() * 2
            // Merged IDs should equal input IDs
            def ids_in = fastq_in.readNames.collect{it.tokenize(" ")[0]}.toSorted().unique()
            def ids_out = fastq_out.readNames.collect{it.tokenize(" ")[0]}.toSorted().unique()
            assert ids_in == ids_out
            // BBMerge summary output should have expected fields
            def bbmerge_tab = path(workflow.out.bbmerge_summary[0][1][0]).csv(sep: "\t", decompress: true)
            def bbmerge_headers_exp = ["seq_id", "bbmerge_frag_length"]
            assert bbmerge_tab.columnNames == bbmerge_headers_exp
        }
    }

    test("Should run without failures on unpaired input") {
        tag "expect_success"
        tag "single_end"
        config "tests/configs/run.config"
        when {
            params {}
            workflow {
                '''
                input[0] = Channel.of(["test", ["${projectDir}/test-data/mergeJoinReadsList/test_000_single.fastq"]])
                input[1] = Channel.of(true)
                '''
            }
        }
        then {
            // Should run without failures
            assert workflow.success
            // Output and input FASTQs should be identical
            def md5_in = path(workflow.out.input_reads[0][1][0]).md5
            def md5_out = path(workflow.out.single_reads[0][1][0]).md5
            assert md5_in == md5_out
            // BBMerge summary output should be empty
            assert workflow.out.bbmerge_summary == []
        }
    }
}
